# -*- coding: utf-8 -*-
"""AI_LAB_EXPERIMENTS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YQLqYbt0Syrq0Rt97VkqaEDSCKD2i2Bv

Q1 Implement and compare the performance of Breadth-First Search (BFS) and Depth-First Search (DFS) on a maze or graph traversal problem.
"""



#Implement and compare the performance of Breadth-First Search (BFS) and Depth-First Search (DFS) on a maze or graph traversal problem.
from collections import deque
from time import time

# Directions: up, down, left, right
DIRECTIONS = [(-1, 0), (1, 0), (0, -1), (0, 1)]

def is_valid(maze, visited, x, y):
    rows, cols = len(maze), len(maze[0])
    return 0 <= x < rows and 0 <= y < cols and maze[x][y] == 0 and not visited[x][y]

def bfs(maze, start, goal):
    queue = deque([start])
    visited = [[False] * len(maze[0]) for _ in maze]
    parent = {}
    visited[start[0]][start[1]] = True

    while queue:
        x, y = queue.popleft()
        if (x, y) == goal:
            break
        for dx, dy in DIRECTIONS:
            nx, ny = x + dx, y + dy
            if is_valid(maze, visited, nx, ny):
                visited[nx][ny] = True
                parent[(nx, ny)] = (x, y)
                queue.append((nx, ny))

    return reconstruct_path(parent, start, goal)

def dfs(maze, start, goal):
    stack = [start]
    visited = [[False] * len(maze[0]) for _ in maze]
    parent = {}
    visited[start[0]][start[1]] = True

    while stack:
        x, y = stack.pop()
        if (x, y) == goal:
            break
        for dx, dy in DIRECTIONS:
            nx, ny = x + dx, y + dy
            if is_valid(maze, visited, nx, ny):
                visited[nx][ny] = True
                parent[(nx, ny)] = (x, y)
                stack.append((nx, ny))

    return reconstruct_path(parent, start, goal)

def reconstruct_path(parent, start, goal):
    path = []
    if goal in parent or goal == start:
        curr = goal
        while curr != start:
            path.append(curr)
            curr = parent[curr]
        path.append(start)
        path.reverse()
    return path

# Sample maze: 0 = open path, 1 = wall
maze = [
    [0, 1, 0, 0, 0],
    [0, 1, 0, 1, 0],
    [0, 0, 0, 1, 0],
    [1, 1, 0, 1, 0],
    [0, 0, 0, 0, 0]
]

start = (0, 0)
goal = (4, 4)

# BFS
start_time = time()
bfs_path = bfs(maze, start, goal)
bfs_time = time() - start_time

# DFS
start_time = time()
dfs_path = dfs(maze, start, goal)
dfs_time = time() - start_time

# Output
print("BFS Path:", bfs_path)
print("BFS Time:", round(bfs_time, 6), "seconds")
print("BFS Path Length:", len(bfs_path))

print("\nDFS Path:", dfs_path)
print("DFS Time:", round(dfs_time, 6), "seconds")
print("DFS Path Length:", len(dfs_path))

"""Q2 Write a program to implement uninformed search algorithms; uniform cost search and bidirectional search, depth limited search"""

# Write a program to implement uninformed search algorithms; uniform cost search and bidirectional search, depth limited search
#Uniform cost search
import heapq

def uniform_cost_search(graph, start, goal):
    queue = [(0, start)]
    visited = set()
    parent = {}

    while queue:
        cost, node = heapq.heappop(queue)

        if node in visited:
            continue
        visited.add(node)

        if node == goal:
            break

        for neighbor, weight in graph.get(node, []):
            if neighbor not in visited:
                heapq.heappush(queue, (cost + weight, neighbor))
                if neighbor not in parent or cost + weight < parent[neighbor][1]:
                    parent[neighbor] = (node, cost + weight)

    return reconstruct_path(parent, start, goal)

def reconstruct_path(parent, start, goal):
    path = []
    if goal in parent or goal == start:
        curr = goal
        while curr != start:
            path.append(curr)
            curr = parent[curr][0] if isinstance(parent[curr], tuple) else parent[curr]
        path.append(start)
        path.reverse()
    return path

# Sample weighted graph
graph = {
    'A': [('B', 2), ('C', 1)],
    'B': [('D', 5)],
    'C': [('D', 2), ('E', 3)],
    'D': [('F', 2)],
    'E': [('F', 1)],
    'F': []
}

path = uniform_cost_search(graph, 'A', 'F')
print("Uniform Cost Search Path:", path)

#Bidirectional Search
from collections import deque

def bidirectional_search(graph, start, goal):
    if start == goal:
        return [start]

    front_visited = {start}
    back_visited = {goal}
    front_queue = deque([start])
    back_queue = deque([goal])
    front_parent = {start: None}
    back_parent = {goal: None}

    while front_queue and back_queue:
        intersect = expand_bfs(graph, front_queue, front_visited, front_parent, back_visited)
        if intersect:
            return merge_paths(front_parent, back_parent, intersect)

        intersect = expand_bfs(graph, back_queue, back_visited, back_parent, front_visited)
        if intersect:
            return merge_paths(front_parent, back_parent, intersect)

    return []

def expand_bfs(graph, queue, visited, parent, other_visited):
    node = queue.popleft()
    for neighbor in graph.get(node, []):
        if isinstance(neighbor, tuple):  # handle UCS-style weighted graphs
            neighbor = neighbor[0]
        if neighbor not in visited:
            visited.add(neighbor)
            parent[neighbor] = node
            queue.append(neighbor)
            if neighbor in other_visited:
                return neighbor
    return None

def merge_paths(front_parent, back_parent, meet_point):
    path = []
    node = meet_point
    while node:
        path.append(node)
        node = front_parent[node]
    path.reverse()
    node = back_parent[meet_point]
    while node:
        path.append(node)
        node = back_parent[node]
    return path

# Simple undirected graph
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A', 'E'],
    'D': ['B', 'F'],
    'E': ['C', 'F'],
    'F': ['D', 'E']
}

path = bidirectional_search(graph, 'A', 'F')
print("Bidirectional Search Path:", path)

#Depth Limited Search
def depth_limited_search(graph, start, goal, limit):
    visited = set()
    path = []

    def dfs(node, depth):
        if depth > limit:
            return False
        visited.add(node)
        path.append(node)

        if node == goal:
            return True

        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                if dfs(neighbor, depth + 1):
                    return True

        path.pop()
        return False

    found = dfs(start, 0)
    return path if found else None

# Graph
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}

path = depth_limited_search(graph, 'A', 'F', limit=3)
print("Depth Limited Search Path:", path)

"""Q3 Write a program to implement heuristic-based search algorithms; A* and Greedy Best-First Search."""

#Write a program to implement heuristic-based search algorithms; A* and Greedy Best-First Search.
import heapq

# Manhattan distance heuristic
def heuristic(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

# Common path reconstruction function
def reconstruct_path(parent, start, goal):
    path = []
    if goal in parent or start == goal:
        current = goal
        while current != start:
            path.append(current)
            current = parent[current]
        path.append(start)
        path.reverse()
    return path

# A* Search Algorithm
def a_star_search(maze, start, goal):
    rows, cols = len(maze), len(maze[0])
    open_set = [(0 + heuristic(start, goal), 0, start)]
    parent = {}
    cost_so_far = {start: 0}
    visited = set()

    while open_set:
        _, cost, current = heapq.heappop(open_set)
        if current == goal:
            break
        visited.add(current)

        for dx, dy in [(-1,0), (1,0), (0,-1), (0,1)]:
            nx, ny = current[0] + dx, current[1] + dy
            neighbor = (nx, ny)

            if 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] == 0:
                new_cost = cost + 1
                if neighbor not in cost_so_far or new_cost < cost_so_far[neighbor]:
                    cost_so_far[neighbor] = new_cost
                    priority = new_cost + heuristic(neighbor, goal)
                    heapq.heappush(open_set, (priority, new_cost, neighbor))
                    parent[neighbor] = current

    return reconstruct_path(parent, start, goal)

# Greedy Best-First Search
def greedy_best_first_search(maze, start, goal):
    rows, cols = len(maze), len(maze[0])
    open_set = [(heuristic(start, goal), start)]
    parent = {}
    visited = set()
    visited.add(start)

    while open_set:
        _, current = heapq.heappop(open_set)
        if current == goal:
            break

        for dx, dy in [(-1,0), (1,0), (0,-1), (0,1)]:
            nx, ny = current[0] + dx, current[1] + dy
            neighbor = (nx, ny)

            if 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] == 0 and neighbor not in visited:
                visited.add(neighbor)
                parent[neighbor] = current
                heapq.heappush(open_set, (heuristic(neighbor, goal), neighbor))

    return reconstruct_path(parent, start, goal)

# Sample maze: 0 = open, 1 = wall
maze = [
    [0, 1, 0, 0, 0],
    [0, 1, 0, 1, 0],
    [0, 0, 0, 1, 0],
    [1, 1, 0, 1, 0],
    [0, 0, 0, 0, 0]
]

start = (0, 0)
goal = (4, 4)

# Run A* Search
a_star_path = a_star_search(maze, start, goal)
print("A* Search Path:", a_star_path)

# Run Greedy Best-First Search
greedy_path = greedy_best_first_search(maze, start, goal)
print("Greedy Best-First Search Path:", greedy_path)

"""Q4 Implement a Genetic Algorithm to solve an optimization-based, path-planning problem. Observe how mutation and crossover parameters affect performance."""

#Implement a Genetic Algorithm to solve an optimization-based, path-planning problem. Observe how mutation and crossover parameters affect performance.
import random

# Define maze: 0 = open, 1 = wall
maze = [
    [0, 1, 0, 0, 0],
    [0, 1, 0, 1, 0],
    [0, 0, 0, 1, 0],
    [1, 1, 0, 1, 0],
    [0, 0, 0, 0, 0]
]

start = (0, 0)
goal = (4, 4)

# Movement definitions
moves = ['U', 'D', 'L', 'R']
move_delta = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}

# GA parameters
POPULATION_SIZE = 100
GENE_LENGTH = 30
MUTATION_RATE = 0.1
CROSSOVER_RATE = 0.8
MAX_GENERATIONS = 200

def move_position(position, move):
    dx, dy = move_delta[move]
    return (position[0] + dx, position[1] + dy)

def is_valid(pos):
    x, y = pos
    return 0 <= x < len(maze) and 0 <= y < len(maze[0]) and maze[x][y] == 0

def fitness(chromosome):
    pos = start
    for move in chromosome:
        next_pos = move_position(pos, move)
        if is_valid(next_pos):
            pos = next_pos
        if pos == goal:
            break
    # Lower fitness is better (distance to goal)
    return abs(pos[0] - goal[0]) + abs(pos[1] - goal[1])

def mutate(chromosome):
    return [random.choice(moves) if random.random() < MUTATION_RATE else gene for gene in chromosome]

def crossover(p1, p2):
    if random.random() > CROSSOVER_RATE:
        return p1[:], p2[:]
    point = random.randint(1, GENE_LENGTH - 2)
    return p1[:point] + p2[point:], p2[:point] + p1[point:]

def create_population():
    return [[random.choice(moves) for _ in range(GENE_LENGTH)] for _ in range(POPULATION_SIZE)]

def select_parent(population, fitnesses):
    total = sum(fitnesses)
    pick = random.uniform(0, total)
    current = 0
    for i, f in enumerate(fitnesses):
        current += f
        if current >= pick:
            return population[i]
    return population[-1]

# Main GA Loop
def genetic_algorithm():
    population = create_population()
    best_path = None

    for generation in range(MAX_GENERATIONS):
        population = sorted(population, key=fitness)
        best = population[0]
        best_fit = fitness(best)

        if best_fit == 0:
            best_path = best
            print(f"Found solution in generation {generation}")
            break

        next_gen = population[:2]  # Elitism
        fitnesses = [1 / (fitness(chromo) + 1) for chromo in population]  # inverse for selection

        while len(next_gen) < POPULATION_SIZE:
            parent1 = select_parent(population, fitnesses)
            parent2 = select_parent(population, fitnesses)
            child1, child2 = crossover(parent1, parent2)
            next_gen.extend([mutate(child1), mutate(child2)])

        population = next_gen

    return best_path or population[0]

# Decode final path
def decode_path(path):
    pos = start
    route = [pos]
    for move in path:
        new_pos = move_position(pos, move)
        if is_valid(new_pos):
            pos = new_pos
            route.append(pos)
        if pos == goal:
            break
    return route

# Run algorithm
final_chromosome = genetic_algorithm()
final_route = decode_path(final_chromosome)

print("Best path (encoded):", final_chromosome)
print("Decoded path (positions):", final_route)

"""Q5 Implement the Grey Wolf Optimization algorithm for an optimization problem, comparing its performance with the Genetic Algorithm and analyzing its convergence behavior."""

#Implement the Grey Wolf Optimization algorithm for an optimization problem, comparing its performance with the Genetic Algorithm and analyzing its convergence behavior.
import numpy as np
import matplotlib.pyplot as plt

# Sphere function (min at [0,0,...,0])
def sphere_function(position):
    return np.sum(position ** 2)

# Grey Wolf Optimizer
def grey_wolf_optimization(fitness_fn, dim, bounds, population_size=20, max_iter=100):
    alpha_pos = np.zeros(dim)
    alpha_score = float("inf")

    beta_pos = np.zeros(dim)
    beta_score = float("inf")

    delta_pos = np.zeros(dim)
    delta_score = float("inf")

    wolves = np.random.uniform(bounds[0], bounds[1], (population_size, dim))
    convergence_curve = []

    for iteration in range(max_iter):
        for i in range(population_size):
            fitness = fitness_fn(wolves[i])

            if fitness < alpha_score:
                alpha_score, alpha_pos = fitness, wolves[i].copy()
            elif fitness < beta_score:
                beta_score, beta_pos = fitness, wolves[i].copy()
            elif fitness < delta_score:
                delta_score, delta_pos = fitness, wolves[i].copy()

        a = 2 - iteration * (2 / max_iter)  # Linearly decreases from 2 to 0

        for i in range(population_size):
            for j in range(dim):
                r1, r2 = np.random.rand(), np.random.rand()

                A1 = 2 * a * r1 - a
                C1 = 2 * r2

                D_alpha = abs(C1 * alpha_pos[j] - wolves[i][j])
                X1 = alpha_pos[j] - A1 * D_alpha

                r1, r2 = np.random.rand(), np.random.rand()
                A2 = 2 * a * r1 - a
                C2 = 2 * r2

                D_beta = abs(C2 * beta_pos[j] - wolves[i][j])
                X2 = beta_pos[j] - A2 * D_beta

                r1, r2 = np.random.rand(), np.random.rand()
                A3 = 2 * a * r1 - a
                C3 = 2 * r2

                D_delta = abs(C3 * delta_pos[j] - wolves[i][j])
                X3 = delta_pos[j] - A3 * D_delta

                wolves[i][j] = (X1 + X2 + X3) / 3

        convergence_curve.append(alpha_score)

    return alpha_pos, alpha_score, convergence_curve

import numpy as np
import random  # Importing random module for selection

# Sphere function (min at [0,0,...,0])
def sphere_function(position):
    return np.sum(position ** 2)

# Genetic Algorithm
def genetic_algorithm(fitness_fn, dim, bounds, population_size=50, generations=100, mutation_rate=0.1, crossover_rate=0.8):
    def create_individual():
        return np.random.uniform(bounds[0], bounds[1], dim)

    def crossover(p1, p2):
        if np.random.rand() > crossover_rate:
            return p1.copy(), p2.copy()
        point = np.random.randint(1, dim)
        return np.concatenate((p1[:point], p2[point:])), np.concatenate((p2[:point], p1[point:]))

    def mutate(individual):
        for i in range(dim):
            if np.random.rand() < mutation_rate:
                individual[i] = np.random.uniform(bounds[0], bounds[1])
        return individual

    population = [create_individual() for _ in range(population_size)]
    convergence_curve = []

    for gen in range(generations):
        population.sort(key=fitness_fn)
        best = population[0]
        convergence_curve.append(fitness_fn(best))

        new_population = population[:2]  # elitism

        while len(new_population) < population_size:
            # Randomly select two parents from the top 20 individuals
            parents = random.sample(population[:20], 2)
            child1, child2 = crossover(parents[0], parents[1])
            new_population.extend([mutate(child1), mutate(child2)])

        population = new_population[:population_size]

    return population[0], fitness_fn(population[0]), convergence_curve

DIM = 30
BOUNDS = (-10, 10)
ITER = 100

# Run GWO
gwo_solution, gwo_score, gwo_curve = grey_wolf_optimization(sphere_function, DIM, BOUNDS, max_iter=ITER)

# Run GA
ga_solution, ga_score, ga_curve = genetic_algorithm(sphere_function, DIM, BOUNDS, generations=ITER)

# Plot Convergence
plt.plot(gwo_curve, label='Grey Wolf Optimization')
plt.plot(ga_curve, label='Genetic Algorithm')
plt.title('Convergence Comparison: GWO vs GA')
plt.xlabel('Iterations')
plt.ylabel('Best Fitness')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# Print results
print("GWO Best Score:", gwo_score)
print("GA Best Score:", ga_score)

"""Q6 Implement local search algorithm Hill Climbing on a problem with multiple local optima."""

#Implement local search algorithm Hill Climbing on a problem with multiple local optima.
import numpy as np
import matplotlib.pyplot as plt

# Ackley Function Definition
def ackley_function(x, y):
    term1 = -20 * np.exp(-0.2 * np.sqrt(0.5 * (x**2 + y**2)))
    term2 = -np.exp(0.5 * (np.cos(2 * np.pi * x) + np.cos(2 * np.pi * y)))
    return term1 + term2 + np.exp(1) + 20

# Hill Climbing Algorithm
def hill_climbing(func, start_point, step_size=0.1, max_iterations=1000):
    current_point = np.array(start_point)
    current_value = func(*current_point)

    path = [current_point]  # To track the path taken during the climb

    for iteration in range(max_iterations):
        # Generate neighbors by taking small steps in each direction
        neighbors = [
            current_point + np.array([step_size, 0]),  # Step in X direction
            current_point + np.array([-step_size, 0]),  # Step in -X direction
            current_point + np.array([0, step_size]),  # Step in Y direction
            current_point + np.array([0, -step_size]),  # Step in -Y direction
        ]

        # Evaluate neighbors
        neighbor_values = [func(*neighbor) for neighbor in neighbors]

        # Find the best neighbor
        best_value = min(neighbor_values)
        best_neighbor = neighbors[neighbor_values.index(best_value)]

        # If the best neighbor is better than the current point, move to the neighbor
        if best_value < current_value:
            current_point = best_neighbor
            current_value = best_value
            path.append(current_point)
        else:
            # No improvement, stop the climb
            break

    return current_point, current_value, path

# Visualization of the Ackley Function
x = np.linspace(-5, 5, 400)
y = np.linspace(-5, 5, 400)
X, Y = np.meshgrid(x, y)
Z = ackley_function(X, Y)

# Plotting the Ackley function surface
fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(X, Y, Z, cmap='jet', edgecolor='none', alpha=0.7)
ax.set_title('Ackley Function')

# Perform Hill Climbing
start_point = (4, 4)  # Starting point for Hill Climbing
solution, solution_value, path = hill_climbing(ackley_function, start_point)

# Plot the path taken by Hill Climbing
path = np.array(path)
ax.plot(path[:, 0], path[:, 1], ackley_function(path[:, 0], path[:, 1]), marker='o', color='r', label='Hill Climbing Path')
ax.legend()

# Show the plot
plt.show()

# Output the result
print(f"Best solution found: {solution}")
print(f"Function value at the solution: {solution_value}")

"""Q7 Develop a simple two-player game (e.g., Tic-Tac-Toe) using Minimax and Alpha-Beta pruning algorithms. Show how optimal strategies are derived in adversarial environments."""

#Develop a simple two-player game (e.g., Tic-Tac-Toe) using Minimax and Alpha-Beta pruning algorithms. Show how optimal strategies are derived in adversarial environments.
import math

# Tic-Tac-Toe constants
PLAYER_X = 'X'
PLAYER_O = 'O'
EMPTY = ' '


# Function to check if the current player has won
def check_winner(board, player):
    # Check rows, columns, and diagonals
    for i in range(3):
        if board[i][0] == board[i][1] == board[i][2] == player:
            return True
        if board[0][i] == board[1][i] == board[2][i] == player:
            return True
    if board[0][0] == board[1][1] == board[2][2] == player:
        return True
    if board[0][2] == board[1][1] == board[2][0] == player:
        return True
    return False


# Function to check if the board is full (no empty spaces)
def is_board_full(board):
    return all(board[i][j] != EMPTY for i in range(3) for j in range(3))


# Minimax Algorithm
def minimax(board, depth, is_maximizing_player):
    if check_winner(board, PLAYER_X):
        return 1  # Maximizing player wins
    if check_winner(board, PLAYER_O):
        return -1  # Minimizing player wins
    if is_board_full(board):
        return 0  # Tie

    if is_maximizing_player:
        best = -math.inf
        for i in range(3):
            for j in range(3):
                if board[i][j] == EMPTY:
                    board[i][j] = PLAYER_X
                    best = max(best, minimax(board, depth + 1, False))
                    board[i][j] = EMPTY
        return best
    else:
        best = math.inf
        for i in range(3):
            for j in range(3):
                if board[i][j] == EMPTY:
                    board[i][j] = PLAYER_O
                    best = min(best, minimax(board, depth + 1, True))
                    board[i][j] = EMPTY
        return best


# Alpha-Beta Pruning Algorithm
def alpha_beta(board, depth, alpha, beta, is_maximizing_player):
    if check_winner(board, PLAYER_X):
        return 1  # Maximizing player wins
    if check_winner(board, PLAYER_O):
        return -1  # Minimizing player wins
    if is_board_full(board):
        return 0  # Tie

    if is_maximizing_player:
        best = -math.inf
        for i in range(3):
            for j in range(3):
                if board[i][j] == EMPTY:
                    board[i][j] = PLAYER_X
                    best = max(best, alpha_beta(board, depth + 1, alpha, beta, False))
                    board[i][j] = EMPTY
                    alpha = max(alpha, best)
                    if beta <= alpha:
                        break  # Beta cut-off
        return best
    else:
        best = math.inf
        for i in range(3):
            for j in range(3):
                if board[i][j] == EMPTY:
                    board[i][j] = PLAYER_O
                    best = min(best, alpha_beta(board, depth + 1, alpha, beta, True))
                    board[i][j] = EMPTY
                    beta = min(beta, best)
                    if beta <= alpha:
                        break  # Alpha cut-off
        return best


# Function to find the best move using Minimax or Alpha-Beta
def find_best_move(board, is_alpha_beta=True):
    best_move = None
    best_val = -math.inf if is_alpha_beta else math.inf

    for i in range(3):
        for j in range(3):
            if board[i][j] == EMPTY:
                board[i][j] = PLAYER_X if is_alpha_beta else PLAYER_O
                move_val = alpha_beta(board, 0, -math.inf, math.inf, True) if is_alpha_beta else minimax(board, 0, True)
                board[i][j] = EMPTY

                if (is_alpha_beta and move_val > best_val) or (not is_alpha_beta and move_val < best_val):
                    best_val = move_val
                    best_move = (i, j)

    return best_move


# Function to print the Tic-Tac-Toe board
def print_board(board):
    for row in board:
        print(" | ".join(row))
        print("-" * 5)


# Main function to simulate the game
def play_game(is_alpha_beta=True):
    board = [[EMPTY for _ in range(3)] for _ in range(3)]
    current_player = PLAYER_X

    while True:
        print_board(board)

        if current_player == PLAYER_X:
            print("Player X's turn (Maximizing player)")
            move = find_best_move(board, is_alpha_beta)
        else:
            print("Player O's turn (Minimizing player)")
            move = find_best_move(board, is_alpha_beta)

        board[move[0]][move[1]] = current_player

        if check_winner(board, current_player):
            print_board(board)
            print(f"Player {current_player} wins!")
            break

        if is_board_full(board):
            print_board(board)
            print("It's a tie!")
            break

        current_player = PLAYER_O if current_player == PLAYER_X else PLAYER_X


# Run the game using Minimax with Alpha-Beta Pruning
play_game(is_alpha_beta=True)  # Set False for regular Minimax

"""Q8 Implement a backtracking algorithm for solving a constraint satisfaction problem, the N-Queens problem, Sudoku."""

#Implement a backtracking algorithm for solving a constraint satisfaction problem, the N-Queens problem, Sudoku.
#N-Queens Problem
def is_safe(board, row, col, N):
    # Check the column
    for i in range(row):
        if board[i][col] == 1:
            return False

    # Check the left diagonal
    for i, j in zip(range(row - 1, -1, -1), range(col - 1, -1, -1)):
        if board[i][j] == 1:
            return False

    # Check the right diagonal
    for i, j in zip(range(row - 1, -1, -1), range(col + 1, N)):
        if board[i][j] == 1:
            return False

    return True

def solve_nqueens(board, row, N):
    # If all queens are placed, return True
    if row == N:
        return True

    for col in range(N):
        if is_safe(board, row, col, N):
            board[row][col] = 1  # Place queen
            if solve_nqueens(board, row + 1, N):
                return True
            board[row][col] = 0  # Backtrack

    return False

def print_board(board):
    for row in board:
        print(" ".join("Q" if col == 1 else "." for col in row))

# Driver Code
N = 8  # You can change the value of N here
board = [[0 for _ in range(N)] for _ in range(N)]

if solve_nqueens(board, 0, N):
    print("Solution found:")
    print_board(board)
else:
    print("No solution exists")

#Sudoku
def is_safe(board, row, col, num):
    # Check if the number is not repeated in the row
    if num in board[row]:
        return False

    # Check if the number is not repeated in the column
    for i in range(9):
        if board[i][col] == num:
            return False

    # Check if the number is not repeated in the 3x3 subgrid
    start_row, start_col = 3 * (row // 3), 3 * (col // 3)
    for i in range(start_row, start_row + 3):
        for j in range(start_col, start_col + 3):
            if board[i][j] == num:
                return False

    return True

def solve_sudoku(board):
    for row in range(9):
        for col in range(9):
            if board[row][col] == 0:  # Find an empty cell
                for num in range(1, 10):
                    if is_safe(board, row, col, num):
                        board[row][col] = num  # Assign number
                        if solve_sudoku(board):  # Recursively solve the board
                            return True
                        board[row][col] = 0  # Backtrack if not valid
                return False  # If no number is valid, return False
    return True  # All cells are filled, puzzle is solved

def print_board(board):
    for row in board:
        print(" ".join(str(cell) for cell in row))

# Driver Code
board = [
    [5, 3, 0, 0, 7, 0, 0, 0, 0],
    [6, 0, 0, 1, 9, 5, 0, 0, 0],
    [0, 9, 8, 0, 0, 0, 0, 6, 0],
    [8, 0, 0, 0, 6, 0, 0, 0, 3],
    [4, 0, 0, 8, 0, 3, 0, 0, 1],
    [7, 0, 0, 0, 2, 0, 0, 0, 6],
    [0, 6, 0, 0, 0, 0, 2, 8, 0],
    [0, 0, 0, 4, 1, 9, 0, 0, 5],
    [0, 0, 0, 0, 8, 0, 0, 7, 9]
]

if solve_sudoku(board):
    print("Sudoku solved:")
    print_board(board)
else:
    print("No solution exists")

"""Q9 Write a program to solve the N-Queens problem using local search strategies (e.g., min-conflicts heuristic) and analyze the effectiveness compared to backtracking."""

#Write a program to solve the N-Queens problem using local search strategies (e.g., min-conflicts heuristic) and analyze the effectiveness compared to backtracking
import random

# Function to calculate the number of conflicts for a given configuration
def calculate_conflicts(board):
    conflicts = 0
    N = len(board)

    # Check row conflicts (not necessary, since only one queen per row)
    # Check column conflicts
    for col in range(N):
        for row in range(col + 1, N):
            if board[row] == board[col] or abs(board[row] - board[col]) == abs(row - col):
                conflicts += 1

    return conflicts

# Function to solve N-Queens using the min-conflicts heuristic
def min_conflicts(N, max_iterations=1000):
    # Initialize a random solution (one queen per row)
    board = list(range(N))  # List of numbers from 0 to N-1 (each index represents a row and the number is the column of the queen)
    random.shuffle(board)

    # Track the number of iterations
    iterations = 0

    while iterations < max_iterations:
        conflicts = calculate_conflicts(board)

        # If there are no conflicts, we have found a solution
        if conflicts == 0:
            return board

        # For each queen, find the row with the least conflicts in its column
        for col in range(N):
            # Find the row with the least conflicts for the current queen
            min_conflict_row = board[col]
            min_conflicts = float('inf')

            for row in range(N):
                if row != board[col]:
                    board_copy = board[:]
                    board_copy[col] = row
                    conflict_count = calculate_conflicts(board_copy)

                    if conflict_count < min_conflicts:
                        min_conflict_row = row
                        min_conflicts = conflict_count

            # Place the queen in the row with the least conflicts
            board[col] = min_conflict_row

        iterations += 1

    return None  # No solution found within max_iterations

# Function to print the N-Queens board
def print_board(board):
    N = len(board)
    for row in range(N):
        line = ['Q' if col == board[row] else '.' for col in range(N)]
        print(' '.join(line))

# Driver Code
N = 8  # Size of the board (8x8 in this case)
solution = min_conflicts(N)

if solution:
    print("Solution found using Min-Conflicts Heuristic:")
    print_board(solution)
else:
    print("No solution found within the maximum number of iterations.")

"""Q10 Simulate a basic Wumpus World environment and implement a simple agent that navigates through it using propositional logic to avoid dangers (e.g., pits, Wumpus). Track the agent’s decisions and learning process."""

#Simulate a basic Wumpus World environment and implement a simple agent that navigates through it using propositional logic to avoid dangers (e.g., pits, Wumpus). Track the agent’s decisions and learning process.
import random

# Constants representing different elements in the Wumpus world
EMPTY = 0
WUMPUS = 1
PIT = 2
GOLD = 3
BREEZE = 4
STENCH = 5

# The Wumpus World environment
class WumpusWorld:
    def __init__(self, size=4):
        self.size = size  # World size (size x size grid)
        self.world = [[EMPTY for _ in range(size)] for _ in range(size)]
        self.agent_position = (0, 0)  # Start at top-left corner
        self.agent_alive = True
        self.has_gold = False
        self.has_arrow = True

        # Randomly place the Wumpus, Pits, and Gold
        self.place_elements()

    def place_elements(self):
        # Randomly place Wumpus
        wumpus_x, wumpus_y = random.randint(0, self.size-1), random.randint(0, self.size-1)
        self.world[wumpus_x][wumpus_y] = WUMPUS

        # Randomly place Pits
        for _ in range(3):  # Place 3 pits
            pit_x, pit_y = random.randint(0, self.size-1), random.randint(0, self.size-1)
            while self.world[pit_x][pit_y] != EMPTY:  # Ensure not overlapping with other elements
                pit_x, pit_y = random.randint(0, self.size-1), random.randint(0, self.size-1)
            self.world[pit_x][pit_y] = PIT

        # Randomly place Gold
        gold_x, gold_y = random.randint(0, self.size-1), random.randint(0, self.size-1)
        while self.world[gold_x][gold_y] != EMPTY:  # Ensure not overlapping with other elements
            gold_x, gold_y = random.randint(0, self.size-1), random.randint(0, self.size-1)
        self.world[gold_x][gold_y] = GOLD

        # Add Breeze and Stench to neighboring cells of pits and Wumpus
        self.add_breeze_and_stench()

    def add_breeze_and_stench(self):
        for x in range(self.size):
            for y in range(self.size):
                if self.world[x][y] == PIT:
                    # Add breeze to adjacent cells
                    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                        nx, ny = x + dx, y + dy
                        if 0 <= nx < self.size and 0 <= ny < self.size and self.world[nx][ny] == EMPTY:
                            self.world[nx][ny] = BREEZE
                elif self.world[x][y] == WUMPUS:
                    # Add stench to adjacent cells
                    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                        nx, ny = x + dx, y + dy
                        if 0 <= nx < self.size and 0 <= ny < self.size and self.world[nx][ny] == EMPTY:
                            self.world[nx][ny] = STENCH

    def display(self):
        print("Wumpus World:")
        for row in self.world:
            print(row)

# The Agent that interacts with the Wumpus World
class Agent:
    def __init__(self, world):
        self.world = world
        self.position = world.agent_position
        self.alive = True
        self.has_gold = False
        self.visited = set()  # Keep track of visited rooms

    def perceive(self):
        x, y = self.position
        percept = []

        # Check for the Breeze (Pit) or Stench (Wumpus)
        if self.world.world[x][y] == BREEZE:
            percept.append("Breeze")
        if self.world.world[x][y] == STENCH:
            percept.append("Stench")
        if self.world.world[x][y] == GOLD:
            percept.append("Gold")
        return percept

    def move(self, direction):
        x, y = self.position
        if direction == "North" and x > 0:
            self.position = (x - 1, y)
        elif direction == "South" and x < self.world.size - 1:
            self.position = (x + 1, y)
        elif direction == "West" and y > 0:
            self.position = (x, y - 1)
        elif direction == "East" and y < self.world.size - 1:
            self.position = (x, y + 1)

        # Check if the agent is in a dangerous room
        percepts = self.perceive()
        if "Breeze" in percepts or "Stench" in percepts:
            if "Breeze" in percepts and random.random() < 0.2:  # Assume 20% chance of falling in a pit
                self.alive = False
            if "Stench" in percepts and random.random() < 0.2:  # Assume 20% chance of encountering Wumpus
                self.alive = False

        # Check if the agent has found gold
        if "Gold" in percepts:
            self.has_gold = True

    def decide(self):
        # Example of a simple decision rule:
        # If agent is alive and has not found gold, move towards unvisited rooms.
        if self.alive and not self.has_gold:
            # Try to move to a random unvisited room
            directions = ["North", "South", "East", "West"]
            random.shuffle(directions)
            for direction in directions:
                self.move(direction)
                if self.position not in self.visited:
                    self.visited.add(self.position)
                    break

# Driver function to simulate the Wumpus World
def simulate():
    world = WumpusWorld(size=4)
    agent = Agent(world)

    steps = 0
    while agent.alive and not agent.has_gold and steps < 100:
        agent.decide()
        steps += 1
        print(f"Step: {steps}, Position: {agent.position}, Alive: {agent.alive}, Has Gold: {agent.has_gold}")

    if agent.alive and agent.has_gold:
        print("Agent found the gold!")
    elif not agent.alive:
        print("Agent has died.")
    else:
        print("Agent could not find the gold.")

# Run the simulation
simulate()

"""Q11 Implementation of Travelling Salesman Problem."""

#Implementation of Travelling Salesman Problem
#Brute Force
import itertools
import math

# Function to calculate distance between two cities (using Euclidean distance)
def euclidean_distance(city1, city2):
    return math.sqrt((city1[0] - city2[0])**2 + (city1[1] - city2[1])**2)

# Function to calculate the total distance of a given path
def total_distance(path, cities):
    distance = 0
    for i in range(len(path) - 1):
        distance += euclidean_distance(cities[path[i]], cities[path[i + 1]])
    distance += euclidean_distance(cities[path[-1]], cities[path[0]])  # Return to the start city
    return distance

# Brute force solution to TSP (generating all permutations)
def tsp_bruteforce(cities):
    n = len(cities)
    all_permutations = itertools.permutations(range(n))  # Generate all permutations of cities
    min_path = None
    min_distance = float('inf')

    for perm in all_permutations:
        dist = total_distance(perm, cities)
        if dist < min_distance:
            min_distance = dist
            min_path = perm

    return min_path, min_distance

# Example usage
cities = [(0, 0), (1, 2), (3, 1), (4, 0)]  # Define cities as (x, y) coordinates
min_path, min_distance = tsp_bruteforce(cities)

print("Optimal Path (Brute Force):", min_path)
print("Minimum Distance (Brute Force):", min_distance)

#Greedy Algorithm
import math

# Function to calculate distance between two cities (using Euclidean distance)
def euclidean_distance(city1, city2):
    return math.sqrt((city1[0] - city2[0])**2 + (city1[1] - city2[1])**2)

# Greedy algorithm to solve TSP
def tsp_greedy(cities):
    n = len(cities)
    visited = [False] * n
    total_distance = 0
    path = [0]  # Start at the first city
    visited[0] = True
    current_city = 0

    for _ in range(n - 1):
        # Find the nearest unvisited city
        nearest_city = None
        min_distance = float('inf')
        for i in range(n):
            if not visited[i]:
                dist = euclidean_distance(cities[current_city], cities[i])
                if dist < min_distance:
                    min_distance = dist
                    nearest_city = i

        # Move to the nearest city
        visited[nearest_city] = True
        path.append(nearest_city)
        total_distance += min_distance
        current_city = nearest_city

    # Add the distance to return to the start city
    total_distance += euclidean_distance(cities[current_city], cities[path[0]])

    return path, total_distance

# Example usage
cities = [(0, 0), (1, 2), (3, 1), (4, 0)]  # Define cities as (x, y) coordinates
path, total_distance = tsp_greedy(cities)

print("Optimal Path (Greedy):", path)
print("Total Distance (Greedy):", total_distance)

#Visualisation
import matplotlib.pyplot as plt

def plot_tsp_path(cities, path):
    x = [cities[i][0] for i in path]
    y = [cities[i][1] for i in path]

    # Close the loop by adding the first city at the end
    x.append(cities[path[0]][0])
    y.append(cities[path[0]][1])

    plt.figure(figsize=(8, 6))
    plt.plot(x, y, 'b-', marker='o', markersize=8, label="TSP Path")
    plt.scatter([city[0] for city in cities], [city[1] for city in cities], color='red', label="Cities")

    for i, city in enumerate(cities):
        plt.text(city[0] + 0.1, city[1] + 0.1, str(i), fontsize=12)

    plt.title("Traveling Salesman Problem Path")
    plt.xlabel("X Coordinate")
    plt.ylabel("Y Coordinate")
    plt.legend()
    plt.grid(True)
    plt.show()

# Example usage: Plotting the TSP path using Greedy solution
plot_tsp_path(cities, path)

"""Q12 Implementation of Missionaries-Cannibals Problem."""

#Implementation of Missionaries-Cannibals Problem
from collections import deque

# Valid moves: (M, C) where M is the number of missionaries and C is the number of cannibals
VALID_MOVES = [
    (2, 0),  # Two missionaries
    (0, 2),  # Two cannibals
    (1, 1),  # One missionary and one cannibal
    (1, 0),  # One missionary
    (0, 1),  # One cannibal
]

# Function to check if the state is valid
def is_valid_state(m, c):
    # Cannibals should not outnumber missionaries on either side
    if m < 0 or c < 0 or m > 3 or c > 3:
        return False
    if (m > 0 and m < c) or (3 - m > 0 and 3 - m < 3 - c):
        return False
    return True

# Function to perform BFS and find the solution
def missionaries_and_cannibals():
    # Start state: (3 missionaries, 3 cannibals, boat on starting side)
    start_state = (3, 3, 0)
    goal_state = (0, 0, 1)

    # Queue for BFS
    queue = deque([(start_state, [])])
    visited = set()
    visited.add(start_state)

    while queue:
        (m, c, b), path = queue.popleft()

        # If goal state is reached
        if (m, c, b) == goal_state:
            return path + [(m, c, b)]

        # Generate all possible valid moves
        for move in VALID_MOVES:
            if b == 0:  # Boat is on the starting side
                new_m, new_c = m - move[0], c - move[1]
                if is_valid_state(new_m, new_c) and (new_m, new_c, 1) not in visited:
                    queue.append(((new_m, new_c, 1), path + [(m, c, b)]))
                    visited.add((new_m, new_c, 1))
            else:  # Boat is on the other side
                new_m, new_c = m + move[0], c + move[1]
                if is_valid_state(new_m, new_c) and (new_m, new_c, 0) not in visited:
                    queue.append(((new_m, new_c, 0), path + [(m, c, b)]))
                    visited.add((new_m, new_c, 0))

    return None  # No solution found

# Print the solution
solution = missionaries_and_cannibals()

if solution:
    print("Solution Path:")
    for step in solution:
        print(f"Missionaries: {step[0]}, Cannibals: {step[1]}, Boat: {'Start' if step[2] == 0 else 'Goal'}")
else:
    print("No solution found!")

